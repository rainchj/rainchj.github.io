<!DOCTYPE html>
<html lang="ko">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Neon Tetris</title>
    <link
        href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700&family=Rajdhani:wght@500;700&display=swap"
        rel="stylesheet">
    <style>
        :root {
            --bg-color: #0d0d20;
            --panel-bg: rgba(255, 255, 255, 0.05);
            --text-color: #fff;
            --neon-blue: #0ff;
            --neon-pink: #f0f;
            --font-main: 'Rajdhani', sans-serif;
            --font-display: 'Orbitron', sans-serif;
        }

        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        body {
            background-color: var(--bg-color);
            color: var(--text-color);
            font-family: var(--font-main);
            height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            overflow: hidden;
        }

        .game-container {
            display: flex;
            gap: 20px;
            padding: 20px;
            border: 2px solid var(--panel-bg);
            border-radius: 10px;
            background: radial-gradient(circle at center, #1a1a3a 0%, #0d0d20 100%);
            box-shadow: 0 0 50px rgba(0, 0, 0, 0.5);
        }

        .game-board-container {
            position: relative;
            border: 2px solid var(--neon-blue);
            box-shadow: 0 0 15px var(--neon-blue), inset 0 0 15px var(--neon-blue);
            border-radius: 4px;
        }

        canvas#tetris {
            display: block;
            background-color: rgba(0, 0, 0, 0.8);
        }

        #game-over {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.85);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 10;
        }

        #game-over.hidden {
            display: none;
        }

        #game-over h2 {
            font-family: var(--font-display);
            color: var(--neon-pink);
            font-size: 2.5rem;
            margin-bottom: 20px;
            text-shadow: 0 0 10px var(--neon-pink);
        }

        .sidebar {
            display: flex;
            flex-direction: column;
            gap: 15px;
            min-width: 180px;
        }

        .info-box {
            background: var(--panel-bg);
            padding: 10px;
            border-radius: 5px;
            border-left: 3px solid var(--neon-pink);
            text-align: center;
        }

        .info-box h3 {
            font-family: var(--font-display);
            color: var(--neon-blue);
            margin-bottom: 5px;
            font-size: 0.9rem;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .info-box div {
            font-size: 1.5rem;
            font-weight: bold;
        }

        #next-piece {
            margin: 0 auto;
            display: block;
        }

        button {
            background: transparent;
            border: 2px solid var(--neon-blue);
            color: var(--neon-blue);
            padding: 10px 20px;
            font-family: var(--font-display);
            font-size: 1rem;
            cursor: pointer;
            transition: all 0.2s;
            text-transform: uppercase;
            border-radius: 5px;
            margin-top: auto;
        }

        button:hover {
            background: var(--neon-blue);
            color: var(--bg-color);
            box-shadow: 0 0 15px var(--neon-blue);
        }

        .controls-info {
            margin-top: 10px;
            font-size: 0.85rem;
            color: #aaa;
        }

        .controls-info p {
            display: flex;
            justify-content: space-between;
            margin-bottom: 5px;
        }

        .controls-info span {
            color: var(--neon-pink);
            font-weight: bold;
        }

        /* Mobile Controls */
        .mobile-controls {
            display: none;
            /* Hidden by default on desktop */
        }

        @media (max-width: 768px) {
            .game-container {
                flex-direction: column;
                align-items: center;
                padding: 10px;
                width: 100vw;
                height: 100vh;
                border: none;
                box-shadow: none;
            }

            canvas#tetris {
                /* adjust canvas for smaller screens if needed, 
                   or rely on container scaling. 
                   But fixed width canvas might overflow small screens slightly.
                   Let's ensure it fits.
                */
                max-width: 100%;
                height: auto;
            }

            .sidebar {
                flex-direction: row;
                flex-wrap: wrap;
                justify-content: center;
                width: 100%;
                min-width: 0;
                gap: 10px;
            }

            .info-box {
                padding: 5px;
                flex: 1;
                min-width: 60px;
            }

            .info-box h3 {
                font-size: 0.7rem;
            }

            .info-box div {
                font-size: 1rem;
            }

            .controls-info {
                display: none;
                /* Hide keyboard info on mobile */
            }

            .mobile-controls {
                display: grid;
                grid-template-columns: repeat(3, 1fr);
                gap: 10px;
                margin-top: 10px;
                width: 100%;
                max-width: 300px;
            }

            .mobile-btn {
                background: rgba(255, 255, 255, 0.1);
                border: 2px solid var(--neon-blue);
                color: white;
                padding: 15px 0;
                border-radius: 10px;
                font-size: 1.5rem;
                touch-action: manipulation;
                display: flex;
                justify-content: center;
                align-items: center;
                user-select: none;
            }

            .mobile-btn:active {
                background: var(--neon-blue);
                color: var(--bg-color);
            }

            /* Grid placement */
            #btn-left {
                grid-column: 1;
                grid-row: 1;
            }

            #btn-down {
                grid-column: 2;
                grid-row: 2;
            }

            #btn-right {
                grid-column: 3;
                grid-row: 1;
            }

            #btn-rotate {
                grid-column: 2;
                grid-row: 1;
            }

            #btn-drop {
                grid-column: 1 / span 3;
                grid-row: 3;
                background: rgba(255, 0, 255, 0.2);
                border-color: var(--neon-pink);
            }
        }
    </style>
</head>

<body>
    <div class="game-container">
        <div class="game-board-container">
            <canvas id="tetris" width="240" height="400"></canvas>
            <div id="game-over" class="hidden">
                <h2>GAME OVER</h2>
                <p>Score: <span id="final-score">0</span></p>
                <button id="restart-btn">Try Again</button>
            </div>
        </div>

        <div class="sidebar">
            <div class="info-box">
                <h3>Next</h3>
                <canvas id="next-piece" width="80" height="80"></canvas>
            </div>

            <div class="info-box">
                <h3>Score</h3>
                <div id="score">0</div>
            </div>

            <div class="info-box">
                <h3>Level</h3>
                <div id="level">1</div>
            </div>

            <div class="info-box">
                <h3>Lines</h3>
                <div id="lines">0</div>
            </div>

            <div class="controls-info">
                <p><span>← →</span> Move</p>
                <p><span>↑</span> Rotate</p>
                <p><span>↓</span> Soft Drop</p>
                <p><span>Space</span> Hard Drop</p>
                <p><span>P</span> Pause</p>
            </div>

            <div class="mobile-controls">
                <button class="mobile-btn" id="btn-left">←</button>
                <button class="mobile-btn" id="btn-rotate">↻</button>
                <button class="mobile-btn" id="btn-right">→</button>
                <button class="mobile-btn" id="btn-down">↓</button>
                <button class="mobile-btn" id="btn-drop">⤓</button>
            </div>

            <button id="start-btn">Start Game</button>
        </div>
    </div>
    <script>
        const canvas = document.getElementById('tetris');
        const ctx = canvas.getContext('2d');
        const nextCanvas = document.getElementById('next-piece');
        const nextCtx = nextCanvas.getContext('2d');

        const COLS = 12;
        const ROWS = 20;
        const BLOCK_SIZE = 20;

        // Scale canvas to match block size
        ctx.scale(BLOCK_SIZE, BLOCK_SIZE);
        nextCtx.scale(BLOCK_SIZE, BLOCK_SIZE);

        // Tetromino definitions
        const PIECES = [
            [
                [0, 0, 0],
                [1, 1, 1],
                [0, 1, 0]
            ],
            [
                [2, 2],
                [2, 2]
            ],
            [
                [0, 3, 3],
                [3, 3, 0],
                [0, 0, 0]
            ],
            [
                [4, 4, 0],
                [0, 4, 4],
                [0, 0, 0]
            ],
            [
                [0, 0, 5],
                [5, 5, 5],
                [0, 0, 0]
            ],
            [
                [6, 0, 0],
                [6, 6, 6],
                [0, 0, 0]
            ],
            [
                [0, 7, 0, 0],
                [0, 7, 0, 0],
                [0, 7, 0, 0],
                [0, 7, 0, 0]
            ]
        ];

        const COLORS = [
            null,
            '#FF0D72', // T - Purple/Pink
            '#0DC2FF', // O - Cyan
            '#0DFF72', // S - Green
            '#F538FF', // Z - Magenta
            '#FF8E0D', // L - Orange
            '#FFE138', // J - Yellow
            '#3877FF'  // I - Blue
        ];

        class Game {
            constructor(ctx, nextCtx) {
                this.ctx = ctx;
                this.nextCtx = nextCtx;
                this.board = this.createBoard(COLS, ROWS);
                this.score = 0;
                this.lines = 0;
                this.level = 0;
                this.gameOver = false;
                this.isPaused = false;

                this.dropCounter = 0;
                this.dropInterval = 1000;

                this.lastTime = 0;

                this.player = {
                    pos: { x: 0, y: 0 },
                    matrix: null,
                    score: 0
                };

                this.nextPiece = null;

                this.reset();
                this.updateScore();
            }

            createBoard(w, h) {
                const matrix = [];
                while (h--) {
                    matrix.push(new Array(w).fill(0));
                }
                return matrix;
            }

            createPiece(type) {
                // Return a copy of the piece matrix
                return PIECES[type].map(row => [...row]);
            }

            getRandomPiece() {
                const type = Math.floor(Math.random() * PIECES.length);
                return this.createPiece(type);
            }

            reset() {
                this.board = this.createBoard(COLS, ROWS);
                this.score = 0;
                this.lines = 0;
                this.level = 1;
                this.dropInterval = 1000;
                this.gameOver = false;
                this.isPaused = false;
                document.getElementById('game-over').classList.add('hidden');

                this.nextPiece = this.getRandomPiece();
                this.playerReset();
                this.updateScore();
                this.start();
            }

            playerReset() {
                this.player.matrix = this.nextPiece;
                this.nextPiece = this.getRandomPiece();
                this.player.pos.y = 0;
                this.player.pos.x = (this.board[0].length / 2 | 0) - (this.player.matrix[0].length / 2 | 0);

                if (this.collide(this.board, this.player)) {
                    this.gameOver = true;
                    document.getElementById('final-score').innerText = this.score;
                    document.getElementById('game-over').classList.remove('hidden');
                    this.stop();
                }

                this.drawNext();
            }

            collide(arena, player) {
                const [m, o] = [player.matrix, player.pos];
                for (let y = 0; y < m.length; ++y) {
                    for (let x = 0; x < m[y].length; ++x) {
                        if (m[y][x] !== 0 &&
                            (arena[y + o.y] && arena[y + o.y][x + o.x]) !== 0) {
                            return true;
                        }
                    }
                }
                return false;
            }

            draw() {
                // Clear board
                this.ctx.fillStyle = '#000';
                this.ctx.fillRect(0, 0, canvas.width, canvas.height);

                // Draw board
                this.drawMatrix(this.board, { x: 0, y: 0 }, this.ctx);
                // Draw player
                this.drawMatrix(this.player.matrix, this.player.pos, this.ctx);
            }

            drawNext() {
                this.nextCtx.fillStyle = '#000';
                this.nextCtx.fillRect(0, 0, nextCanvas.width, nextCanvas.height);

                // Center the piece in the next box
                const xOffset = (4 - this.nextPiece[0].length) / 2;
                const yOffset = (4 - this.nextPiece.length) / 2;

                this.drawMatrix(this.nextPiece, { x: xOffset, y: yOffset }, this.nextCtx);
            }

            drawMatrix(matrix, offset, context) {
                matrix.forEach((row, y) => {
                    row.forEach((value, x) => {
                        if (value !== 0) {
                            context.fillStyle = COLORS[value];
                            context.fillRect(x + offset.x, y + offset.y, 1, 1);

                            // Add a glimmer effect
                            context.lineWidth = 0.05;
                            context.strokeStyle = 'white';
                            context.strokeRect(x + offset.x, y + offset.y, 1, 1);
                        }
                    });
                });
            }

            merge(arena, player) {
                player.matrix.forEach((row, y) => {
                    row.forEach((value, x) => {
                        if (value !== 0) {
                            arena[y + player.pos.y][x + player.pos.x] = value;
                        }
                    });
                });
            }

            rotate(matrix, dir) {
                for (let y = 0; y < matrix.length; ++y) {
                    for (let x = 0; x < y; ++x) {
                        [
                            matrix[x][y],
                            matrix[y][x],
                        ] = [
                                matrix[y][x],
                                matrix[x][y],
                            ];
                    }
                }
                if (dir > 0) {
                    matrix.forEach(row => row.reverse());
                } else {
                    matrix.reverse();
                }
            }

            playerRotate(dir) {
                const pos = this.player.pos.x;
                let offset = 1;
                this.rotate(this.player.matrix, dir);
                while (this.collide(this.board, this.player)) {
                    this.player.pos.x += offset;
                    offset = -(offset + (offset > 0 ? 1 : -1));
                    if (offset > this.player.matrix[0].length) {
                        this.rotate(this.player.matrix, -dir);
                        this.player.pos.x = pos;
                        return;
                    }
                }
            }

            playerDrop() {
                this.player.pos.y++;
                if (this.collide(this.board, this.player)) {
                    this.player.pos.y--;
                    this.merge(this.board, this.player);
                    this.arenaSweep();
                    this.playerReset();
                }
                this.dropCounter = 0;
            }

            playerHardDrop() {
                while (!this.collide(this.board, this.player)) {
                    this.player.pos.y++;
                }
                this.player.pos.y--;
                this.merge(this.board, this.player);
                this.arenaSweep();
                this.playerReset();
                this.dropCounter = 0;
            }

            playerMove(dir) {
                this.player.pos.x += dir;
                if (this.collide(this.board, this.player)) {
                    this.player.pos.x -= dir;
                }
            }

            arenaSweep() {
                let rowCount = 0;
                outer: for (let y = this.board.length - 1; y > 0; --y) {
                    for (let x = 0; x < this.board[y].length; ++x) {
                        if (this.board[y][x] === 0) {
                            continue outer;
                        }
                    }

                    const row = this.board.splice(y, 1)[0].fill(0);
                    this.board.unshift(row);
                    ++y;
                    rowCount++;
                }

                if (rowCount > 0) {
                    // Scoring: 1: 40, 2: 100, 3: 300, 4: 1200 * (level + 1)
                    const lineScores = [0, 40, 100, 300, 1200];
                    this.score += lineScores[rowCount] * (this.level); // Simplification avoiding level + 1 if level is not 0 based
                    this.lines += rowCount;

                    // Level up every 10 lines
                    this.level = Math.floor(this.lines / 10) + 1;

                    // Increase speed
                    this.dropInterval = Math.max(100, 1000 - (this.level - 1) * 100);

                    this.updateScore();
                }
            }

            updateScore() {
                document.getElementById('score').innerText = this.score;
                document.getElementById('level').innerText = this.level;
                document.getElementById('lines').innerText = this.lines;
            }

            update(time = 0) {
                if (this.isPaused || this.gameOver) return;

                const deltaTime = time - this.lastTime;
                this.lastTime = time;
                this.dropCounter += deltaTime;

                if (this.dropCounter > this.dropInterval) {
                    this.playerDrop();
                }

                this.draw();
                this.animationId = requestAnimationFrame(this.update.bind(this));
            }

            start() {
                if (this.gameOver) {
                    this.reset();
                } else if (!this.animationId) {
                    this.update();
                }
            }

            stop() {
                cancelAnimationFrame(this.animationId);
                this.animationId = null;
            }

            togglePause() {
                if (this.gameOver) return;
                this.isPaused = !this.isPaused;
                if (!this.isPaused) {
                    this.lastTime = performance.now();
                    this.update();
                } else {
                    this.stop();
                    // Optional: Draw PAUSED text
                    this.ctx.fillStyle = 'rgba(0,0,0,0.5)';
                    this.ctx.fillRect(0, 0, canvas.width, canvas.height);
                    this.ctx.fillStyle = 'white';
                    this.ctx.font = '1px Arial';
                    this.ctx.fillText('PAUSED', 3, 10);
                }
            }
        }

        const game = new Game(ctx, nextCtx);

        // Controls
        document.addEventListener('keydown', event => {
            if (game.gameOver) return;

            if (event.code === 'ArrowLeft') {
                game.playerMove(-1);
            } else if (event.code === 'ArrowRight') {
                game.playerMove(1);
            } else if (event.code === 'ArrowDown') {
                game.playerDrop();
            } else if (event.code === 'ArrowUp') {
                game.playerRotate(1);
            } else if (event.code === 'Space') {
                event.preventDefault(); // Prevent scrolling
                game.playerHardDrop();
            } else if (event.code === 'KeyP') {
                game.togglePause();
            }
        });

        document.getElementById('start-btn').addEventListener('click', () => {
            if (game.gameOver) {
                game.reset();
            } else if (game.isPaused) {
                game.togglePause();
            } else {
                // Restart logic if needed, or just focus
                // For simplicity, let's make it a reset button if game over, else nothing or pause?
                // Let's make it a Reset/Start button
                game.reset();
            }
        });

        document.getElementById('restart-btn').addEventListener('click', () => {
            game.reset();
        });

        // Initial start
        game.update();

        // Mobile Controls
        const mobileBtnLeft = document.getElementById('btn-left');
        const mobileBtnRight = document.getElementById('btn-right');
        const mobileBtnRotate = document.getElementById('btn-rotate');
        const mobileBtnDown = document.getElementById('btn-down');
        const mobileBtnDrop = document.getElementById('btn-drop');

        function addMobileControl(btn, action) {
            if (!btn) return;

            // Use touchstart for immediate response, preventDefault to avoid double-firing or zooming
            btn.addEventListener('touchstart', (e) => {
                e.preventDefault();
                if (game.gameOver || game.isPaused) return;
                action();
            }, { passive: false });

            // Fallback for mouse clicks on desktop testing
            btn.addEventListener('click', (e) => {
                if (game.gameOver || game.isPaused) return;
                action();
                // Remove focus to prevent Enter key from triggering last button
                btn.blur();
            });
        }

        addMobileControl(mobileBtnLeft, () => game.playerMove(-1));
        addMobileControl(mobileBtnRight, () => game.playerMove(1));
        addMobileControl(mobileBtnRotate, () => game.playerRotate(1));
        addMobileControl(mobileBtnDown, () => game.playerDrop());
        addMobileControl(mobileBtnDrop, () => game.playerHardDrop());
    </script>
    <div style="position: absolute; bottom: 20px; width: 100%; text-align: center; z-index: 100;">
        <span style="color: rgb(215, 251, 206);">☞ <a href="index.html"
                style="color: inherit; text-decoration: none;">홈으로</a></span>
    </div>
</body>

</html>